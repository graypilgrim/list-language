\documentclass{article}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{secdot}
\sectiondot{subsection}
\usepackage{scrextend}
\usepackage{booktabs}
\usepackage{array}
\usepackage{ltablex}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{parskip}
\addtokomafont{labelinglabel}{\sffamily}
\usepackage{color}
\definecolor{light-gray}{gray}{0.95}
\newcommand{\keyword}[1]{\colorbox{light-gray}{\texttt{#1}}}
\newcommand{\code}[1]{\texttt{#1}}
\usepackage{textcomp}

\title{\vspace{7cm}\LARGE Techniki kompilacji\\semestr 17L\\Język do operacji na listach}
\author{\LargeŁukasz Wlazły\\nr albumu: 269365}
\date{}

\begin{document}
\maketitle
\pagenumbering{gobble}
\newpage
\pagenumbering{arabic}

\section{Założenia projektowe}
\begin{enumerate}
\item Język będzie posiadał statyczne typowanie.
\item Język będzie obsługiwał typy liczbowe (int oraz float), typ logiczny (bool) oraz brak typu zwracanego dla funkcji (void).
\item Typy proste będą przekazywane do funkcji przez wartość, listy natomiast będą przekazywane przez referencję.
\item Nie będzie możliwe zagnieżdżanie deklaracji funkcji, deklaracja może odbywać się tylko w zasięgu globalnym.
\item Program rozpoczyna się od funkcji \code{main} o typie \keyword{bool}.
\end{enumerate}

\section{Atomy leksykalne}
\keyword{list}, \keyword{if}, \keyword{else}, \keyword{while}, \keyword{for}, \keyword{in}, \keyword{return}\\
\keyword{true}, \keyword{false}, \\
\keyword{(}, \keyword{)}, \keyword{[}, \keyword{]}, \keyword{\{}, \keyword{\}}, \\
\keyword{=}, \keyword{+}, \keyword{-}, \keyword{*}, \keyword{/} \\
\keyword{==}, \keyword{!=}, \keyword{<=}, \keyword{>=}, \\
\keyword{\&\&}, \keyword{||}, \\
\keyword{;}
\newpage
\section{Gramatyka}
\code{program} \textrightarrow \code{funsDefs} \\
\code{funsDefs} \textrightarrow \code{funDef | funDef funsDefs} \\
\code{funDef} \textrightarrow \code{funDecl\{ exprs \} | funDecl\{ exprs retExpr \}} \\
\code{funDecl} \textrightarrow \code{varDecl( args )} \\
\code{args} \textrightarrow \code{varDecl | varDecl, args} \\
\code{exprs} \textrightarrow \code{expr | expr\keyword{;} | \keyword{\{} exprs \keyword{\}} | expr\keyword{;} exprs} \\
\code{expr} \textrightarrow \code{condExpr | loopExpr | callExpr | indexExpr | varDef | varDecl | listExpr | retExpr} \\

\code{condExpr} \textrightarrow \code{ifExpr | ifExpr elseExpr} \\
\code{ifExpr} \textrightarrow \code{\keyword{if (} logicStmt \keyword{)} exprs } \\
\code{elseExpr} \textrightarrow \code{\keyword{else} exprs} \\
\code{retExpr} \textrightarrow \code{\keyword{return} val} \\
\code{callExpr} \textrightarrow \code{identifier\keyword{(}vals\keyword{)}} \\
\code{logicStmt} \textrightarrow \code{val logicOp val | logicStmt logicTie logicStmt} \\

\code{loopExpr} \textrightarrow \code{whileExpr | forExpr} \\
\code{whileExpr} \textrightarrow \code{\keyword{while (} logicStmt \keyword{)} exprs} \\
\code{forExpr} \textrightarrow \code{\keyword{for (} varDef \keyword{;} logicStmt \keyword{;} assignExpr \keyword{)} exprs}

\code{listExpr} \textrightarrow \code{\keyword{[]} | \keyword{[} number \keyword{]} | \keyword{[} basicListIter \keyword{]} | \keyword{[} basicListIter condExpr \keyword{]} } \\
\code{basicListIter} \textrightarrow \code{ expr \keyword{for} identifier \keyword{in} identifier} \\

\code{varDef} \textrightarrow \code{varDecl \keyword{=} val} \\
\code{varDecl} \textrightarrow \code{type identifier} \\
\code{vals} \textrightarrow \code{val | val, vals }
\code{val} \textrightarrow \code{lVal | rVal} \\
\code{lVal} \textrightarrow \code{identifier | indexExpr} \\
\code{rVal} \textrightarrow \code{identifier | callExpr | indexExpr | listExpr | lVal mathOp rVal | number | boolVal} \\
\code{indexExpr} \textrightarrow \code{identifier\keyword{[}identifier\keyword{]} | identifier\keyword{[}intNumber\keyword{]}} \\

\code{identifier} \textrightarrow \code{letter*} \\
\code{type} \textrightarrow \code{\keyword{int} | \keyword{float} | \keyword{list} | \keyword{bool} | \keyword{void}} \\
\code{logicOp} \textrightarrow \code{\keyword{==} | \keyword{!=} | \keyword{<=} | \keyword{>=}} \\
\code{logicTie} \textrightarrow \code{\keyword{\&\&} | \keyword{||}} \\
\code{mathOp} \textrightarrow \code{\keyword{=} | \keyword{+} | \keyword{-} | \keyword{*} | \keyword{/}} \\
\code{letter} \textrightarrow \code{\keyword{A} \ldots \keyword{z}} \\
\code{number} \textrightarrow \code{intNumber | floatNumber} \\
\code{intNumber} \textrightarrow \code{digit*} \\
\code{floatNumber} \textrightarrow \code{digit*.digit*} \\
\code{digit} \textrightarrow \code{\keyword{0} \ldots \keyword{9}} \\

\newpage
\section{Przykłady}
\subsection{Proste użycie wywołania funkcji}
\begin{lstlisting}[tabsize=2]
int add(int x, int y) {
	return x + y;
}

int main() {
	int a = 6;
	int b = 7;
	int wynik = add(a, b);

	return false;
}
\end{lstlisting}

\subsection{Funkcja rekurencyjna}
\begin{lstlisting}[tabsize=2]
int factorial(int x) {
	if (x == 1)
		return 1;
	return x*factorial(x-1);
}
\end{lstlisting}

\subsection{Operacje na listach}
\begin{lstlisting}[tabsize=2]
int factorial(int x) {
	if (x <= 1)
		return 1;
	return x*factorial(x-1);
}

int main() {
	list a = [5];
	for (int i = 0; i < 5; i=i+1)
		a[i] = i;

	list f = [factorial(i) for i in a];

	return false;
}

\end{lstlisting}

\end{document}
